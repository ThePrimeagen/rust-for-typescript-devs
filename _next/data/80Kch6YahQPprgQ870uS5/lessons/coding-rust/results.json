{"pageProps":{"post":{"attributes":{"title":"Learn Rustlang Results","description":"Lets go deep on results."},"html":"<h2 id=\"to-throw-or-not-to-throw-that-is-the-question\">To throw or not to throw, that is the question</h2>\n<p>Another place where typescript and rust have fundamentally different design\ndecisions.</p>\n<p>Ask yourself the following questions</p>\n<ul>\n<li>what function throws an error?</li>\n<li>who handles the error if thrown?</li>\n<li>what can be throw? (look at the promise reject definition (reason: any))</li>\n</ul>\n<p>with javascript you learn by trial. <br/></p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"how-rust-handles-errors\">How Rust Handles Errors</h2>\n<p>Errors are values</p>\n<p>This means that there is no throwing. You get a value that is either a value\nor an error.</p>\n<p>Notice this is very similar to Option.</p>\n<ul>\n<li>Option is value or undefined</li>\n<li>Result is value or error value</li>\n</ul>\n<br />\n\n<h2 id=\"if-err--nil\">if err != nil</h2>\n<p>yes, the golang meme of error handling doesn&#39;t exist in rust. Rust handles\nerrors better than go.</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"i-am-going-to-make-some-assumptions\">I am going to make some assumptions</h2>\n<p>You don&#39;t need me to show you another example of how to handle enums because\nthat&#39;s all we have been doing.</p>\n<p>The definition of a result</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Result</span>&lt;V, E&gt; {\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(V),\n    <span class=\"hljs-title function_ invoke__\">Err</span>(E),\n}\n</code></pre>\n<br />\n<br />\n<br />\n<br />\n\n<p>Also, rust has <code>Ok</code> and <code>Err</code> as first class citizens</p>\n<br />\n<br />\n<br />\n<br />\n\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Ok</span>(value) = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>() {\n    <span class=\"hljs-comment\">// something with the value</span>\n}\n\n<span class=\"hljs-keyword\">match</span> <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>() {\n    <span class=\"hljs-title function_ invoke__\">Ok</span>(value) =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;oh yeah, value! {}&quot;</span>, value);\n    <span class=\"hljs-title function_ invoke__\">Err</span>(e) =&gt; eprintln!(<span class=\"hljs-string\">&quot;ohh no... {}&quot;</span>, e);\n}\n\n<span class=\"hljs-comment\">// you don&#x27;t care about the error</span>\n_ = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>();\n\n<span class=\"hljs-comment\">// yolo</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span> = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n\n<span class=\"hljs-comment\">// respectful yolo</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span> = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>().<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">&quot;should never fail&quot;</span>);\n\n<span class=\"hljs-comment\">// defaults</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span> = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>().<span class=\"hljs-title function_ invoke__\">unwrap_or</span>(<span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-comment\">// convert to option</span>\n<span class=\"hljs-comment\">// Ok(V) =&gt; Some(V)</span>\n<span class=\"hljs-comment\">// Err(E) =&gt; None</span>\n<span class=\"hljs-comment\">// bai felicia</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span> = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>().<span class=\"hljs-title function_ invoke__\">ok</span>();\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span> = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>()\n    .<span class=\"hljs-title function_ invoke__\">map</span>(|value| value + <span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span> = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>()\n    .<span class=\"hljs-title function_ invoke__\">and_then</span>(|value| <span class=\"hljs-title function_ invoke__\">another_possible_error</span>(value))\n    .<span class=\"hljs-title function_ invoke__\">and_then</span>(|value| <span class=\"hljs-title function_ invoke__\">again</span>(value));\n\n<span class=\"hljs-comment\">// If your function returns an error, you can do this!</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span> = <span class=\"hljs-title function_ invoke__\">a_function_that_can_error</span>()?;\n</code></pre>\n<h2 id=\"side-note\">Side Note</h2>\n<p>there are two <code>crates</code> (rust package) that work very well with errors</p>\n<ul>\n<li>thiserror - great for creating your own errors. should be used in libraries</li>\n<li>anyhow - great for applications.</li>\n</ul>\n<p>We will use anyhow shortly</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"another-small-exercise\">Another small exercise!</h2>\n<p>This is going to combine all of our knowledge of <code>Iterator</code>s, <code>Option</code>s, and\nnewly introduced <code>Result</code>. <br /></p>\n<p>But! Lets go in small steps</p>\n<ol>\n<li>read the first argument passed to the program</li>\n</ol>\n<ul>\n<li><code>cargo run -- this_is_an_arg</code></li>\n<li><code>npx ts-node file this_is_an_arg</code></li>\n</ul>\n<ol>\n<li>the first argument is a name and path to the file to read</li>\n<li>print out each line of the file</li>\n</ol>\n<pre><code class=\"hljs language-typescript\">process.<span class=\"hljs-property\">argv</span>[<span class=\"hljs-number\">2</span>] &lt;--- first arg to program\n</code></pre>\n<p>Now we have already done some of this, so this should become a bit easier, lets\nstart with TypeScript.</p>\n<p>file you should use, save as proj/numbers</p>\n<pre><code>1\n5\n9\n33\n</code></pre>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"complete-code\">Complete Code</h2>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> fs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;fs&quot;</span>;\nfs.<span class=\"hljs-title function_\">readFileSync</span>(process.<span class=\"hljs-property\">argv</span>[<span class=\"hljs-number\">2</span>])\n  .<span class=\"hljs-title function_\">toString</span>()\n  .<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>)\n  .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">line</span>) =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(line));\n</code></pre>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<p>Ok... now try this</p>\n<pre><code class=\"hljs language-bash\">npx ts-node src/index.ts filethatdoesntexist\n</code></pre>\n<p>what happens?\nwhy?</p>\n<p>ok... again</p>\n<pre><code class=\"hljs language-bash\">npx ts-node src/index.ts\n</code></pre>\n<p>?? WHY YOU DO THIS TO ME</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"rust\">Rust</h2>\n<p>Ok lets try the same thing in rust. It will be a bit more involved.</p>\n<p>I&#39;ll give you some hints.</p>\n<pre><code class=\"hljs language-rust\">std::env::<span class=\"hljs-title function_ invoke__\">args</span>().<span class=\"hljs-title function_ invoke__\">nth</span>(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// &lt;--- gets the first argument</span>\n                        <span class=\"hljs-comment\">//      passed to the program</span>\n</code></pre>\n<p>if you forgot</p>\n<pre><code class=\"hljs language-rust\">std::fs::<span class=\"hljs-title function_ invoke__\">read_to_string</span>(...) <span class=\"hljs-comment\">// reads a file to string</span>\n</code></pre>\n<p>I&#39;ll give you a second, then i&#39;ll do it</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"complete-code-1\">Complete Code</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">arg</span> = std::env::<span class=\"hljs-title function_ invoke__\">args</span>().<span class=\"hljs-title function_ invoke__\">nth</span>(<span class=\"hljs-number\">1</span>)\n        .<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">&quot;please provide a file name as an argument&quot;</span>);\n\n    std::fs::<span class=\"hljs-title function_ invoke__\">read_to_string</span>(arg)\n        .<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">&quot;unable to read the file provided&quot;</span>)\n        .<span class=\"hljs-title function_ invoke__\">lines</span>()\n        .<span class=\"hljs-title function_ invoke__\">for_each</span>(|line| <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;{}&quot;</span>, line));\n}\n</code></pre>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"discussion-compare-typescript-w-rust\">[Discussion]: Compare TypeScript w/ Rust</h2>\n<p>what makes rust better or worse in this example?</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"lets-add-more-requirements\">Lets add more requirements</h2>\n<p>lets only print out lines that are <code>number</code>s and lines that are not, lets print\nout <code>Line not a number</code></p>\n<p>First, TypeScript, i&#39;ll give you a moment</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"complete-code-2\">Complete Code</h2>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">import</span> fs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;fs&quot;</span>;\nfs.<span class=\"hljs-title function_\">readFileSync</span>(process.<span class=\"hljs-property\">argv</span>[<span class=\"hljs-number\">2</span>])\n  .<span class=\"hljs-title function_\">toString</span>()\n  .<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>)\n  .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">line</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> v = <span class=\"hljs-built_in\">parseInt</span>(line);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isNaN</span>(v)) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Line not a number&quot;</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);\n    }\n  });\n</code></pre>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"now-how-do-we-do-this-in-rust\">Now how do we do this in rust?</h2>\n<p>one piece of knowledge, <code>parse</code> is needed.</p>\n<p>A <code>&amp;str</code> has <code>parse</code> function which allows for any <code>Type</code> implementing\n<code>FromStr</code> to be parsed from a string. Now this sounds like a bunch of\nnon-sense, don&#39;t worry, we will go through this more deeply soon.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">// -------v</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span>: <span class=\"hljs-type\">usize</span> = <span class=\"hljs-string\">&quot;5&quot;</span>.<span class=\"hljs-title function_ invoke__\">parse</span>();\n\n<span class=\"hljs-comment\">// ---------------------v</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span> = <span class=\"hljs-string\">&quot;5&quot;</span>.parse::&lt;<span class=\"hljs-type\">usize</span>&gt;();\n\n<span class=\"hljs-comment\">// ------------v</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">mult</span>() <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">usize</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;5&quot;</span>.<span class=\"hljs-title function_ invoke__\">parse</span>().<span class=\"hljs-title function_ invoke__\">unwrap_or</span>(<span class=\"hljs-number\">0</span>);\n}\n</code></pre>\n<p>I&#39;ll give you a moment to try it out, then i&#39;ll do it\n(think pattern matching)</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"complete-code-3\">Complete Code</h2>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">arg</span> = std::env::<span class=\"hljs-title function_ invoke__\">args</span>().<span class=\"hljs-title function_ invoke__\">nth</span>(<span class=\"hljs-number\">1</span>)\n        .<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">&quot;please provide a file name as an argument&quot;</span>);\n\n    std::fs::<span class=\"hljs-title function_ invoke__\">read_to_string</span>(arg)\n        .<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">&quot;unable to read the file provided&quot;</span>)\n        .<span class=\"hljs-title function_ invoke__\">lines</span>()\n        .<span class=\"hljs-title function_ invoke__\">for_each</span>(|line| {\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Ok</span>(value) = line.parse::&lt;<span class=\"hljs-type\">usize</span>&gt;() {\n                <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;{}&quot;</span>, value);\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Line not a number&quot;</span>);\n            }\n        });\n}\n</code></pre>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"discussion-which-one-was-easier-to-get-right\">[Discussion]: Which one was easier to get right?</h2>\n<p>Try to think through the problem as if you knew Rust as well as TypeScript</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"a-case-for-rust\">A Case for rust</h2>\n<p>In the simplest sense, you always know where your errors happen, you always\nknow when undefineds can happen</p>\n<ul>\n<li>Result saves you from errors you should be able to prevent</li>\n<li>Option saves you from <code>undefined is not a function</code></li>\n<li>Rust doesn&#39;t save you from bad logic, we are all bad programmers, sowwy</li>\n</ul>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n<h2 id=\"questions\">Questions?</h2>\n<p>Get them out of the way now, even if its not <code>Result</code> based.</p>\n<p>Remember:</p>\n<ul>\n<li>If you don&#39;t understand something, this is a great time to understand it\nbetter</li>\n<li>If you don&#39;t understand something, guarantee the person next to you is\nstruggling with the same thing</li>\n<li>If you don&#39;t ask, who will?</li>\n</ul>\n<p>The next section is going to be much more rust focused.</p>\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n","slug":"results","title":"Learn Rustlang Results","section":"Coding Rust","icon":"info-circle","filePath":"/home/runner/work/rust-for-typescript-devs/rust-for-typescript-devs/lessons/02-coding-rust/D-results.md","nextSlug":"/rust-for-typescript-devs/lessons/borrow-checker/a-light-intro-to-heap","prevSlug":"/rust-for-typescript-devs/lessons/coding-rust/options"}},"__N_SSG":true}