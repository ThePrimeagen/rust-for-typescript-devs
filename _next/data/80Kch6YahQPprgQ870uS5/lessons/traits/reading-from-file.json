{"pageProps":{"post":{"attributes":{"title":"Reading Shapes from a File"},"html":"<h2 id=\"what-if-we-wanted-to-read-our-shapes-from-a-file\">What if we wanted to read our shapes from a file?</h2>\n<p><code>FromStr</code> allows for a <code>&amp;str</code> to become a <code>Type</code> through the method <code>parse</code></p>\n<p>You may remember from earlier, this code</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">// -------v</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">foo</span>: <span class=\"hljs-type\">usize</span> = <span class=\"hljs-string\">&quot;5&quot;</span>.<span class=\"hljs-title function_ invoke__\">parse</span>(); <span class=\"hljs-comment\">// &lt;-- parse infers the usize parse</span>\n                              <span class=\"hljs-comment\">// due to type</span>\n</code></pre>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/> \n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h2 id=\"before-we-implement-a-fromstr-for-both-circle-and-rect\">Before we implement a FromStr for both Circle and Rect</h2>\n<p>Whenever i deal with errors in small applications, at this point I just default\nto using the <code>anyhow</code> crate. It makes working with errors very simple.</p>\n<p>execute <code>cargo add anyhow</code></p>\n<pre><code class=\"hljs language-bash\">➜  rust-typescript git:(master) ✗ cargo add anyhow\n    Updating crates.io index\n      Adding anyhow (workspace) to dependencies.\n             Features as of v1.0.68:\n             + std\n             - backtrace\n</code></pre>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h2 id=\"ok-lets-use-anyhow-and-fromstr\">Ok, lets use Anyhow and FromStr</h2>\n<p>We will implement a <code>Circle</code> and <code>Rectangle</code> parse</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h2 id=\"complete-code\">Complete Code</h2>\n<p>src/shapes/rect.rs</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">FromStr</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Rectangle</span> {\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Err</span> = anyhow::Error;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from_str</span>(s: &amp;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Result</span>&lt;<span class=\"hljs-keyword\">Self</span>, <span class=\"hljs-keyword\">Self</span>::<span class=\"hljs-literal\">Err</span>&gt; {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">parts</span>: <span class=\"hljs-type\">Vec</span>&lt;&amp;<span class=\"hljs-type\">str</span>&gt; = s.<span class=\"hljs-title function_ invoke__\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>).<span class=\"hljs-title function_ invoke__\">collect</span>();\n        <span class=\"hljs-keyword\">if</span> parts.<span class=\"hljs-title function_ invoke__\">len</span>() != <span class=\"hljs-number\">4</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Err</span>(anyhow::anyhow!(<span class=\"hljs-string\">&quot;Invalid number of parts&quot;</span>));\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Ok</span>(Rectangle {\n            x: parts[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_ invoke__\">parse</span>()?,\n            y: parts[<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_ invoke__\">parse</span>()?,\n            width: parts[<span class=\"hljs-number\">2</span>].<span class=\"hljs-title function_ invoke__\">parse</span>()?,\n            height: parts[<span class=\"hljs-number\">3</span>].<span class=\"hljs-title function_ invoke__\">parse</span>()?,\n        });\n    }\n}\n</code></pre>\n<p>src/shapes/circle.rs</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">FromStr</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Circle</span> {\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Err</span> = anyhow::Error;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from_str</span>(s: &amp;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Result</span>&lt;<span class=\"hljs-keyword\">Self</span>, <span class=\"hljs-keyword\">Self</span>::<span class=\"hljs-literal\">Err</span>&gt; {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">parts</span>: <span class=\"hljs-type\">Vec</span>&lt;&amp;<span class=\"hljs-type\">str</span>&gt; = s.<span class=\"hljs-title function_ invoke__\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>).<span class=\"hljs-title function_ invoke__\">collect</span>();\n        <span class=\"hljs-keyword\">if</span> parts.<span class=\"hljs-title function_ invoke__\">len</span>() != <span class=\"hljs-number\">3</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Err</span>(anyhow::anyhow!(<span class=\"hljs-string\">&quot;Invalid number of parts&quot;</span>));\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Ok</span>(Circle {\n            x: parts[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_ invoke__\">parse</span>()?,\n            y: parts[<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_ invoke__\">parse</span>()?,\n            radius: parts[<span class=\"hljs-number\">2</span>].<span class=\"hljs-title function_ invoke__\">parse</span>()?,\n        });\n    }\n}\n</code></pre>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h2 id=\"lets-create-a-file\">Lets create a file!</h2>\n<p>We will use this file, parse out the contents, build our circle and rects, and\ntest to see if any circles intesect our rect (though... its not a good\nformula).</p>\n<p><proj>/shapes</p>\n<pre><code class=\"hljs language-bash\">rect 0 0 10 20\ncircle 12 20 1\ncircle 0 20 4\nrect 10 10 10 10\n</code></pre>\n<p>Requires</p>\n<ul>\n<li>reading a file (we have done)</li>\n<li>create an enum to store either a <code>Circle</code> or <code>Rect</code> in</li>\n<li>read each line and perhaps use <code>split_once</code> (recommend using pattern matching)</li>\n<li>find any <em>adjancent</em> collision</li>\n</ul>\n<p>You have done most of this so far throughout the day, lets see if you can do\nthis by yourself.</p>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n<br/>\n\n<h2 id=\"complete-code-1\">Complete Code</h2>\n<p>src/main.rs</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">mod</span> shapes;\n\n<span class=\"hljs-keyword\">use</span> std::{<span class=\"hljs-type\">str</span>::FromStr, fmt::Display};\n\n<span class=\"hljs-keyword\">use</span> anyhow::<span class=\"hljs-type\">Result</span>;\n<span class=\"hljs-keyword\">use</span> shapes::{rect::Rectangle, circle::Circle, collisions::{Points, Contains, Collidable}};\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Shape</span> {\n    <span class=\"hljs-title function_ invoke__\">Rect</span>(Rectangle),\n    <span class=\"hljs-title function_ invoke__\">Circ</span>(Circle),\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">FromStr</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Shape</span> {\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Err</span> = anyhow::Error;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from_str</span>(s: &amp;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Result</span>&lt;<span class=\"hljs-keyword\">Self</span>, <span class=\"hljs-keyword\">Self</span>::<span class=\"hljs-literal\">Err</span>&gt; {\n        <span class=\"hljs-keyword\">let</span> (shape, data) = s.<span class=\"hljs-title function_ invoke__\">split_once</span>(<span class=\"hljs-string\">&quot; &quot;</span>)\n            .<span class=\"hljs-title function_ invoke__\">ok_or</span>(anyhow::anyhow!(<span class=\"hljs-string\">&quot;Invalid shape&quot;</span>))?;\n\n        <span class=\"hljs-keyword\">match</span> shape {\n            <span class=\"hljs-string\">&quot;circle&quot;</span> =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Ok</span>(Shape::<span class=\"hljs-title function_ invoke__\">Circ</span>(data.<span class=\"hljs-title function_ invoke__\">parse</span>()?)),\n            <span class=\"hljs-string\">&quot;rect&quot;</span> =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Ok</span>(Shape::<span class=\"hljs-title function_ invoke__\">Rect</span>(data.<span class=\"hljs-title function_ invoke__\">parse</span>()?)),\n            _ =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Err</span>(anyhow::anyhow!(<span class=\"hljs-string\">&quot;Invalid shape&quot;</span>))\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Points</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Shape</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">points</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> shapes::collisions::PointIter {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            Shape::<span class=\"hljs-title function_ invoke__\">Rect</span>(rect) =&gt; <span class=\"hljs-keyword\">return</span> rect.<span class=\"hljs-title function_ invoke__\">points</span>(),\n            Shape::<span class=\"hljs-title function_ invoke__\">Circ</span>(circ) =&gt; <span class=\"hljs-keyword\">return</span> circ.<span class=\"hljs-title function_ invoke__\">points</span>(),\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Contains</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Shape</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">contains_point</span>(&amp;<span class=\"hljs-keyword\">self</span>, point: (<span class=\"hljs-type\">f64</span>, <span class=\"hljs-type\">f64</span>)) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            Shape::<span class=\"hljs-title function_ invoke__\">Rect</span>(rect) =&gt; <span class=\"hljs-keyword\">return</span> rect.<span class=\"hljs-title function_ invoke__\">contains_point</span>(point),\n            Shape::<span class=\"hljs-title function_ invoke__\">Circ</span>(circ) =&gt; <span class=\"hljs-keyword\">return</span> circ.<span class=\"hljs-title function_ invoke__\">contains_point</span>(point),\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Display</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Shape</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">fmt</span>(&amp;<span class=\"hljs-keyword\">self</span>, f: &amp;<span class=\"hljs-keyword\">mut</span> std::fmt::Formatter&lt;<span class=\"hljs-symbol\">&#x27;_</span>&gt;) <span class=\"hljs-punctuation\">-&gt;</span> std::fmt::<span class=\"hljs-type\">Result</span> {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            Shape::<span class=\"hljs-title function_ invoke__\">Rect</span>(rect) =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">&quot;{}&quot;</span>, rect),\n            Shape::<span class=\"hljs-title function_ invoke__\">Circ</span>(circ) =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">write!</span>(f, <span class=\"hljs-string\">&quot;{}&quot;</span>, circ),\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Result</span>&lt;()&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">file</span> = std::fs::<span class=\"hljs-title function_ invoke__\">read_to_string</span>(<span class=\"hljs-string\">&quot;shapes&quot;</span>)?;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">shapes</span> = file\n        .<span class=\"hljs-title function_ invoke__\">lines</span>()\n        .<span class=\"hljs-title function_ invoke__\">filter_map</span>(|line| line.<span class=\"hljs-title function_ invoke__\">parse</span>().<span class=\"hljs-title function_ invoke__\">ok</span>())\n        .collect::&lt;<span class=\"hljs-type\">Vec</span>&lt;Shape&gt;&gt;();\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">collisions</span>: <span class=\"hljs-type\">Vec</span>&lt;(&amp;Shape, &amp;Shape)&gt; = shapes\n        .<span class=\"hljs-title function_ invoke__\">iter</span>()\n        .<span class=\"hljs-title function_ invoke__\">skip</span>(<span class=\"hljs-number\">1</span>)\n        .<span class=\"hljs-title function_ invoke__\">zip</span>(shapes.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">take</span>(shapes.<span class=\"hljs-title function_ invoke__\">len</span>() - <span class=\"hljs-number\">1</span>))\n        .<span class=\"hljs-title function_ invoke__\">filter</span>(|(a, b)| a.<span class=\"hljs-title function_ invoke__\">collide</span>(b))\n        .<span class=\"hljs-title function_ invoke__\">collect</span>();\n\n    <span class=\"hljs-title function_ invoke__\">for</span> (a, b) <span class=\"hljs-keyword\">in</span> collisions {\n        <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Collision: {} {}&quot;</span>, a, b);\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Ok</span>(());\n}\n</code></pre>\n","slug":"reading-from-file","title":"Reading Shapes from a File","section":"Traits","icon":"info-circle","filePath":"/home/runner/work/rust-for-typescript-devs/rust-for-typescript-devs/lessons/04-traits/G-reading-from-file.md","nextSlug":"/rust-for-typescript-devs/lessons/the-end/the-end","prevSlug":"/rust-for-typescript-devs/lessons/traits/refactor-rectangle-circle"}},"__N_SSG":true}